namespace testapi . flatbuffers;

table Simple {
  n: int;
  s: string;
}

table Primitives {
  // scalars (excluding enums) + string
  a: uint8 = 1;
  b: uint16 = 1;
  c: uint32 = 1;
  d: uint64 = 1;
  e: int8 = 1;
  f: int16 = 1;
  g: int32 = 1;
  h: int64 = 1;
  i: float32 = 1;
  j: float64 = 1;
  k: bool;
  l: string;
}
root_type Primitives;
file_identifier "PRIM";

table ManyTables {
  n: int;
  x: Simple;
  y: Simple;
  z: Simple;
}

enum Color:ushort { Red = 0, Green, Blue = 2, Gray = 5, Black = 8 }

struct StructWithEnum {
  x: byte;
  y: Color;
  z: byte;
}

table Enums {
  x: Color = Blue;
  y: StructWithEnum;
  xs: [Color] (required);
  ys: [StructWithEnum];
}

union Weapon { Sword, Axe }
table Sword { x: string; }
table Axe { y: int; }

table TableWithUnion {
  uni: Weapon;
  uniReq: Weapon (required);
}

table Vectors {
  a: [uint8];
  b: [uint16];
  c: [uint32];
  d: [uint64];
  e: [int8];
  f: [int16];
  g: [int32];
  h: [int64];
  i: [float32];
  j: [float64];
  k: [bool];
  l: [string];
}

struct RegularStruct {
  x: int;
  y: uint;
}

struct IrregularStruct {
  w: int;
  x: ubyte;
  y: long;
  z: bool;
}

struct WithNestedStruct {
  x: RegularStruct;
  y: IrregularStruct;
}

table Structs {
  w: RegularStruct;
  x: RegularStruct;
  y: IrregularStruct;
  z: WithNestedStruct;
}

table VectorOfTables {
  xs: [Axe];
}

struct ThreeBytes {
  x: ubyte;
  y: byte;
  z: byte;
}

table VectorOfStructs {
  xs: [ThreeBytes];
}

table VectorOfUnions {
  xs: [Weapon];
  xsReq: [Weapon] (required);
}

// These are used for testing padding and alignment of structs / struct fields
struct Align1 (force_align: 4) {
  x: short;
}

struct Align2 {
  x: Align1;
  y: ulong;
  z: ubyte;
}

table AlignT {
  x: Align1;
  y: Align2;
  xs: [Align1];
  ys: [Align2];
}


// TODO: add support

// union UnionOfStructs { UOS_A, UOS_B }
// struct UOS_A { x: int32; }
// struct UOS_B { x: int64; }

// union UnionOfStrings {
//   Name: string,
//   Thing: string,
//   Id: UnionA
// }

// table ManyUnionsOfStructs {
//   x: UnionOfStructs;
//   xs: [UnionOfStructs];
// }

// table MenyUnionsOfStrings {
//   x: UnionOfString;
//   xs: [UnionOfStrings]
// }

